"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const utils_array_1 = require("@ionic/utils-array");
const utils_fs_1 = require("@ionic/utils-fs");
const crypto = require("crypto");
const fs = require("fs");
const path = require("path");
const color_1 = require("../../lib/color");
const command_1 = require("../../lib/command");
const errors_1 = require("../../lib/errors");
class DeployManifestCommand extends command_1.Command {
    async getMetadata() {
        return {
            name: 'manifest',
            type: 'project',
            summary: 'Generates a manifest file for the deploy service from a built app directory',
            groups: ["hidden" /* HIDDEN */],
        };
    }
    async run() {
        if (!this.project) {
            throw new errors_1.FatalException(`Cannot run ${color_1.input('ionic deploy manifest')} outside a project directory.`);
        }
        const buildDir = path.resolve(this.project.directory, 'www'); // TODO: this is hard-coded
        const manifest = await this.getFilesAndSizesAndHashesForGlobPattern(buildDir);
        await utils_fs_1.writeFile(path.resolve(buildDir, 'pro-manifest.json'), JSON.stringify(manifest, undefined, 2), { encoding: 'utf8' });
    }
    async getFilesAndSizesAndHashesForGlobPattern(buildDir) {
        const contents = await utils_fs_1.readdirp(buildDir);
        const stats = await utils_array_1.map(contents, async (f) => [f, await utils_fs_1.stat(f)]);
        const files = stats.filter(([, stat]) => !stat.isDirectory());
        const items = await Promise.all(files.map(([f, stat]) => this.getFileAndSizeAndHashForFile(buildDir, f, stat)));
        return items.filter(item => item.href !== 'pro-manifest.json');
    }
    async getFileAndSizeAndHashForFile(buildDir, file, stat) {
        const buffer = await this.readFile(file);
        return {
            href: path.relative(buildDir, file),
            size: stat.size,
            integrity: this.getIntegrity(buffer),
        };
    }
    async readFile(file) {
        return new Promise((resolve, reject) => {
            fs.readFile(file, (err, buffer) => {
                if (err) {
                    return reject(err);
                }
                resolve(buffer);
            });
        });
    }
    getIntegrity(data) {
        return ['sha256', 'sha384', 'sha512']
            .map(algorithm => {
            const hash = crypto.createHash(algorithm);
            hash.update(data);
            return algorithm + '-' + hash.digest('base64');
        })
            .join(' ');
    }
}
exports.DeployManifestCommand = DeployManifestCommand;
